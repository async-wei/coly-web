<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>About - Chemistry Olympiad Questions</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@500;600&display=swap" rel="stylesheet">
</head>
<body>
    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        uniform float uTime;
        uniform float uEnableWaves;

        void main() {
            vUv = uv;
            float time = uTime * 5.;
            float waveFactor = uEnableWaves;
            vec3 transformed = position;

            transformed.x += sin(time + position.y) * .5 * waveFactor;
            transformed.y += cos(time + position.z) * .15 * waveFactor;
            transformed.z += sin(time + position.x) * waveFactor;

            gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec2 vUv;
        uniform float uTime;
        uniform sampler2D uTexture;

        void main() {
            float time = uTime;
            vec2 pos = vUv;

            float r = texture2D(uTexture, pos + cos(time * 2. - time + pos.x) * .01).r;
            float g = texture2D(uTexture, pos + tan(time * .5 + pos.x - time) * .01).g;
            float b = texture2D(uTexture, pos - cos(time * 2. + time + pos.y) * .01).b;
            float a = texture2D(uTexture, pos).a;
            gl_FragColor = vec4(r, g, b, a);
        }
    </script>
    <nav>
        <div class="nav-links">
            <a href="website.html">HOME</a>
            <a href="https://www.acs.org" target="_blank">ACS</a>
        </div>
        <div class="nav-right">
            <button class="theme-toggle" onclick="toggleDarkMode()" aria-label="Toggle dark mode">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                </svg>
            </button>
            <a href="https://github.com" class="github-btn" target="_blank">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                </svg>
                <span>Github</span>
            </a>
        </div>
    </nav>
    <div class="container">
        <div class="about-columns">
            <div class="about-column">
                <h2>What is this website?</h2>
                <p>
                    Studying for the USNCO can be a repetitive and tedious process, with past exams being grouped into 60-question, time-consuming tests. 
                    To make studying more efficient and rewarding, I've created this website which contains 3000+ organized USNCO MCQ questions released by the ACS from 
                    2000 to 2025 -- all easily accessible through a nice UI. I hope you will give it a try.
                </p>
            </div>
            <div class="about-spacer">
                <div id="ascii-art-container"></div>
            </div>
            <div class="about-column">
                <h2>How was it made?</h2>
                <p>
                    The problems were extracted as .png images through a Python program using the PyMuPDF and pdfplumber libraries, 
                    automatically sorted by question topics, and then displayed onto this Website through Dropbox image links. The website is written in HTML/CSS
                    with dynamic components using various Javascript Libraries such as Three.js from ReactBits. This entire project was made in 3 days!
                </p>
            </div>
        </div>
    </div>

    <script>
        // FIRST
        (function initializeDarkMode() {
            const savedDarkMode = localStorage.getItem('darkMode');
            if (savedDarkMode === 'true') {
                document.body.classList.add('dark-mode');
            }
        })();
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');

            localStorage.setItem('darkMode', isDark);
        }
        // ASCII Art fx
        (function() {
            const container = document.getElementById('ascii-art-container');
            if (!container || typeof THREE === 'undefined') return;

            Math.map = function (n, start, stop, start2, stop2) {
                return ((n - start) / (stop - start)) * (stop2 - start2) + start2;
            };
            const PX_RATIO = window.devicePixelRatio || 1;
            const vertexShader = document.getElementById('vertexShader').textContent;
            const fragmentShader = document.getElementById('fragmentShader').textContent;
            class AsciiFilter {
                constructor(renderer, options = {}) {
                    this.renderer = renderer;
                    this.domElement = document.createElement('div');
                    this.domElement.style.position = 'absolute';
                    this.domElement.style.top = '0';
                    this.domElement.style.left = '5%';
                    this.domElement.style.width = '100%';
                    this.domElement.style.height = '100%';
                    this.pre = document.createElement('pre');
                    this.domElement.appendChild(this.pre);
                    this.canvas = document.createElement('canvas');
                    this.context = this.canvas.getContext('2d');
                    this.domElement.appendChild(this.canvas);
                    this.deg = 0;
                    this.invert = options.invert ?? true;
                    this.fontSize = options.fontSize ?? 12;
                    this.fontFamily = options.fontFamily ?? "'Courier New', monospace";
                    this.charset = options.charset ?? " .'`^\",:;Il!i~+_-?][}{1)(|/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$";
                    this.context.imageSmoothingEnabled = false;
                    this.onMouseMove = this.onMouseMove.bind(this);
                    document.addEventListener('mousemove', this.onMouseMove);
                }
                setSize(width, height) {
                    this.width = width;
                    this.height = height;
                    this.renderer.setSize(width, height);
                    this.reset();
                    this.center = { x: width / 2, y: height / 2 };
                    this.mouse = { x: this.center.x, y: this.center.y };
                }
                reset() {
                    this.context.font = `${this.fontSize}px ${this.fontFamily}`;
                    const charWidth = this.context.measureText('A').width;
                    this.cols = Math.floor(this.width / (this.fontSize * (charWidth / this.fontSize)));
                    this.rows = Math.floor(this.height / this.fontSize);
                    this.canvas.width = this.cols;
                    this.canvas.height = this.rows;
                    this.pre.style.fontFamily = this.fontFamily;
                    this.pre.style.fontSize = `${this.fontSize}px`;
                }
                render(scene, camera) {
                    this.renderer.render(scene, camera);
                    const w = this.canvas.width;
                    const h = this.canvas.height;
                    this.context.clearRect(0, 0, w, h);
                    if (this.context && w && h) {
                        this.context.drawImage(this.renderer.domElement, 0, 0, w, h);
                    }
                    this.asciify(this.context, w, h);
                    this.hue();
                }
                onMouseMove(e) {
                    this.mouse = { x: e.clientX * PX_RATIO, y: e.clientY * PX_RATIO };
                }
                get dx() {
                    return this.mouse.x - this.center.x;
                }
                get dy() {
                    return this.mouse.y - this.center.y;
                }
                hue() {
                    const deg = (Math.atan2(this.dy, this.dx) * 180) / Math.PI;
                    this.deg += (deg - this.deg) * 0.075;
                    this.domElement.style.filter = `hue-rotate(${this.deg.toFixed(1)}deg)`;
                }
                asciify(ctx, w, h) {
                    if (w && h) {
                        const imgData = ctx.getImageData(0, 0, w, h).data;
                        let str = '';
                        for (let y = 0; y < h; y++) {
                            for (let x = 0; x < w; x++) {
                                const i = x * 4 + y * 4 * w;
                                const [r, g, b, a] = [imgData[i], imgData[i + 1], imgData[i + 2], imgData[i + 3]];
                                if (a === 0) {
                                    str += ' ';
                                    continue;
                                }
                                let gray = (0.3 * r + 0.6 * g + 0.1 * b) / 255;
                                let idx = Math.floor((1 - gray) * (this.charset.length - 1));
                                if (this.invert) idx = this.charset.length - idx - 1;
                                str += this.charset[idx];
                            }
                            str += '\\n';
                        }
                        this.pre.innerHTML = str;
                    }
                }
                dispose() {
                    document.removeEventListener('mousemove', this.onMouseMove);
                }
            }
            class CanvasTxt {
                constructor(txt, options = {}) {
                    this.canvas = document.createElement('canvas');
                    this.context = this.canvas.getContext('2d');
                    this.txt = txt;
                    this.fontSize = options.fontSize || 200;
                    this.fontFamily = options.fontFamily || 'Arial';
                    this.color = options.color || '#fdf9f3';
                    this.font = `600 ${this.fontSize}px ${this.fontFamily}`;
                }
                resize() {
                    this.context.font = this.font;
                    const metrics = this.context.measureText(this.txt);
                    const textWidth = Math.ceil(metrics.width) + 20;
                    const textHeight = Math.ceil(metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent) + 20;
                    this.canvas.width = textWidth;
                    this.canvas.height = textHeight;
                }
                render() {
                    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.context.fillStyle = this.color;
                    this.context.font = this.font;
                    const metrics = this.context.measureText(this.txt);
                    const yPos = 10 + metrics.actualBoundingBoxAscent;
                    this.context.fillText(this.txt, 10, yPos);
                }
                get width() {
                    return this.canvas.width;
                }
                get height() {
                    return this.canvas.height;
                }
                get texture() {
                    return this.canvas;
                }
            }
            class CanvAscii {
                constructor(options, containerElem, width, height) {
                    this.textString = options.text;
                    this.asciiFontSize = options.asciiFontSize;
                    this.textFontSize = options.textFontSize;
                    this.textColor = options.textColor;
                    this.planeBaseHeight = options.planeBaseHeight;
                    this.container = containerElem;
                    this.width = width;
                    this.height = height;
                    this.enableWaves = options.enableWaves;
                    this.camera = new THREE.PerspectiveCamera(45, this.width / this.height, 1, 1000);
                    this.camera.position.z = 30;
                    this.scene = new THREE.Scene();
                    this.mouse = { x: 0, y: 0 };
                    this.onMouseMove = this.onMouseMove.bind(this);
                    this.setMesh();
                    this.setRenderer();
                }
                setMesh() {
                    this.textCanvas = new CanvasTxt(this.textString, {
                        fontSize: this.textFontSize,
                        fontFamily: 'IBM Plex Mono',
                        color: this.textColor
                    });
                    this.textCanvas.resize();
                    this.textCanvas.render();
                    this.texture = new THREE.CanvasTexture(this.textCanvas.texture);
                    this.texture.minFilter = THREE.NearestFilter;
                    const textAspect = this.textCanvas.width / this.textCanvas.height;
                    const baseH = this.planeBaseHeight;
                    const planeW = baseH * textAspect;
                    const planeH = baseH;
                    this.geometry = new THREE.PlaneGeometry(planeW, planeH, 36, 36);
                    this.material = new THREE.ShaderMaterial({
                        vertexShader,
                        fragmentShader,
                        transparent: true,
                        uniforms: {
                            uTime: { value: 0 },
                            uTexture: { value: this.texture },
                            uEnableWaves: { value: this.enableWaves ? 1.0 : 0.0 }
                        }
                    });
                    this.mesh = new THREE.Mesh(this.geometry, this.material);
                    this.scene.add(this.mesh);
                }
                setRenderer() {
                    this.renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
                    this.renderer.setPixelRatio(1);
                    this.renderer.setClearColor(0x000000, 0);

                    this.filter = new AsciiFilter(this.renderer, {
                        fontFamily: 'IBM Plex Mono',
                        fontSize: this.asciiFontSize,
                        invert: true
                    });
                    this.container.appendChild(this.filter.domElement);
                    this.setSize(this.width, this.height);
                    this.container.addEventListener('mousemove', this.onMouseMove);
                    this.container.addEventListener('touchmove', this.onMouseMove);
                }
                setSize(w, h) {
                    this.width = w;
                    this.height = h;
                    this.camera.aspect = w / h;
                    this.camera.updateProjectionMatrix();
                    this.filter.setSize(w, h);
                    this.center = { x: w / 2, y: h / 2 };
                }
                load() {
                    this.animate();
                }
                onMouseMove(evt) {
                    const e = evt.touches ? evt.touches[0] : evt;
                    const bounds = this.container.getBoundingClientRect();
                    const x = e.clientX - bounds.left;
                    const y = e.clientY - bounds.top;
                    this.mouse = { x, y };
                }
                animate() {
                    const animateFrame = () => {
                        this.animationFrameId = requestAnimationFrame(animateFrame);
                        this.render();
                    };
                    animateFrame();
                }
                render() {
                    const time = new Date().getTime() * 0.001;
                    this.textCanvas.render();
                    this.texture.needsUpdate = true;
                    this.mesh.material.uniforms.uTime.value = Math.sin(time);
                    this.updateRotation();
                    this.filter.render(this.scene, this.camera);
                }
                updateRotation() {
                    const x = Math.map(this.mouse.y, 0, this.height, 0.5, -0.5);
                    const y = Math.map(this.mouse.x, 0, this.width, -0.5, 0.5);
                    this.mesh.rotation.x += (x - this.mesh.rotation.x) * 0.05;
                    this.mesh.rotation.y += (y - this.mesh.rotation.y) * 0.05;
                }
                dispose() {
                    cancelAnimationFrame(this.animationFrameId);
                    this.filter.dispose();
                    this.container.removeChild(this.filter.domElement);
                    this.container.removeEventListener('mousemove', this.onMouseMove);
                    this.container.removeEventListener('touchmove', this.onMouseMove);
                    this.renderer.dispose();
                }
            }
            function initAscii() {
                const { width, height } = container.getBoundingClientRect();
                console.log('Container dimensions:', width, height);
                if (width > 0 && height > 0) {
                    console.log('Initializing ASCII art...');
                    const viewportWidth = window.innerWidth - 700;
                    const scaleFactor = viewportWidth / 1920; 
                    const asciiFontSize = Math.max(1, Math.floor(10 * scaleFactor));
                    const textFontSize = Math.max(60, Math.floor(200 * scaleFactor));
                    const planeBaseHeight = Math.max(6, Math.floor(15 * scaleFactor));
                    const ascii = new CanvAscii(
                        {
                            text: 'CHEM!',
                            asciiFontSize: asciiFontSize,
                            textFontSize: textFontSize,
                            textColor: '#fdf9f3',
                            planeBaseHeight: planeBaseHeight,
                            enableWaves: true
                        },
                        container,
                        width,
                        height
                    );
                    ascii.load();
                    console.log('ASCII art initialized successfully!');
                    let resizeTimeout;
                    window.addEventListener('resize', () => {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => {
                            const { width: w, height: h } = container.getBoundingClientRect();
                            if (w > 0 && h > 0) {
                                ascii.setSize(w, h);
                                // dynamic font sizing for diff displays
                                const newViewportWidth = window.innerWidth;
                                const newScaleFactor = newViewportWidth / 1920;
                                const newAsciiFontSize = Math.max(4, Math.floor(10 * newScaleFactor));
                                const newTextFontSize = Math.max(60, Math.floor(200 * newScaleFactor));
                                const newPlaneBaseHeight = Math.max(6, Math.floor(15 * newScaleFactor));
                                ascii.asciiFontSize = newAsciiFontSize;
                                ascii.textFontSize = newTextFontSize;
                                ascii.planeBaseHeight = newPlaneBaseHeight;
                                // filter and canvas settings
                                if (ascii.filter) {
                                    ascii.filter.fontSize = newAsciiFontSize;
                                    ascii.filter.reset();
                                }
                                if (ascii.textCanvas) {
                                    ascii.textCanvas.fontSize = newTextFontSize;
                                    ascii.textCanvas.font = `600 ${newTextFontSize}px ${ascii.textCanvas.fontFamily}`;
                                    ascii.textCanvas.resize();
                                }
                            }
                        }, 250);
                    });
                } else {
                    console.warn('Container has no dimensions, retrying...');
                    setTimeout(initAscii, 100);
                }
            }
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initAscii);
            } else {
                setTimeout(initAscii, 100);
            }
        })();
    </script>
</body>
</html>
